<h1 align="center">
System and Method for Solving Logic Instances
</h1>

Abstract: We introduce a method of solving boolean 3-satisfiability logic instances by testing for the coverage of clauses that evaluate to false. We show how to set up a search space that represents a logic instance and identify 3 ways to advance forward through this search space, each corresponding to one of the 3 literals of the clause that we label the “jump”, the “limit”, and the “base”.

Claims:

1. We split the search space into at least 4 equal portions and search them individually, encoding the highest-order bits of each portion of the search space with the different permutations of the bits representative of the number of equal portions chosen.  
2. We identify where a jump literal- the lowest-order literal of a clause- is immediately succeeded by its inverse and replace the second jump with the lower-order of the limit literals (the second-lowest-order literals of each of the clauses) of the two clauses as a new effective jump.  
3. We identify where four successive jumps were replaced by two effective jumps offered by limit literals that are inverses of each other and replace the effective jump offered by the second limit literal by an effective jump offered by the lowest-order of the base literals (the highest-order literals of each of the clauses) of the four clauses.

Specification: For a logic instance having n binary variables and k clauses we create an n-bit number Z and assign each binary variable to a unique bit location on Z. Starting with the beginning of the portion of the search space, we advance Z forward through the search space by what we’ll call “jumps” whereby for each jump a bit is identified that can be inverted. We continue identifying these bits and inverting them until either the entirety of all portions of the search space are found to have coverage of clauses evaluating to false or a value of Z is found not to have any available jumps, whereby the truth values of the bits of Z represent a satisfying assignment of truth values for the logic instance. We label the lowest-order literal of a given clause the “jump” literal, we label the second-lowest-order literal of that clause the “limit” literal, and we label the highest-order literal of that clause the “base” literal. We also show the conditions under which a jump can be replaced by a limit or a base to create a new effective jump of a higher order.

A jump literal x is identified when for a given value of Z one of the k clauses evaluates to false. Observe that when this occurs, all values of Z having the same bit values of higher- and equal-order to the jump variable x are covered (“coverage of clauses that evaluate to false”) by this one clause, and until we advance Z to the location where the bit value of x inverts. Carrying this strategy forward, if a jump is immediately followed by its inverse, we can replace the second jump by a new effective jump offered by the lower-order of the limit literals of the clauses containing the two successive jumps. We can do this because all values of Z up to the value where the lower-order limit literal inverts contain one of those two clauses evaluating to false. Carrying this strategy forward once more, when we identify two successive effective jumps offered by limit literals that are inverses of each other, we have identified a condition where all values of Z contain one of those two clauses containing our limit literals evaluating to false up to the location where the lowest order base literal among all four of our clauses inverts. When multiple clauses evaluate to false as a result of the value of Z being tested, we utilize the greedy approach and select the clause giving us the highest effective jump. When a clause has one false truth identity in it, we only consider the limit literal, and when a clause has two false truth identities in it, we only consider the jump literal.

When we invert a bit, we are adding a perfect power of 2 to Z, which means that we perform any carry operations just as we would with the addition of any two numbers. After performing the addition operation on Z, we set all bits of lower order than this bit’s order to false because between the value of Z having all false values of lower order this bit’s order and the value of Z without having set these values to false there could be a value of Z that results in no clauses evaluating to false.

Note that an effective jump offered by a limit literal or base literal is never guaranteed and may not be available, and as all clauses have exactly 3 literals, the 2 highest-order bits of Z may not be accessible. To resolve this we chop the search space into at least 4 equal portions and encode each of the 4 permutations of those 2 bits into the highest-order bits of each of the 4 corresponding search space portions.
